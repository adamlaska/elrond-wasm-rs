// Code generated by the multiversx-sc proxy generator. DO NOT EDIT.

////////////////////////////////////////////////////
////////////////// AUTO-GENERATED //////////////////
////////////////////////////////////////////////////

#![allow(dead_code)]
#![allow(clippy::all)]

use multiversx_sc::proxy_imports::*;

pub struct OrderBookPairProxy;

impl<Env, From, To, Gas> TxProxyTrait<Env, From, To, Gas> for OrderBookPairProxy
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    type TxProxyMethods = OrderBookPairProxyMethods<Env, From, To, Gas>;

    fn proxy_methods(self, tx: Tx<Env, From, To, (), Gas, (), ()>) -> Self::TxProxyMethods {
        OrderBookPairProxyMethods { wrapped_tx: tx }
    }
}

pub struct OrderBookPairProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    wrapped_tx: Tx<Env, From, To, (), Gas, (), ()>,
}

#[rustfmt::skip]
impl<Env, From, Gas> OrderBookPairProxyMethods<Env, From, (), Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    Gas: TxGas<Env>,
{
    pub fn init<
        Arg0: ProxyArg<TokenId<Env::Api>>,
        Arg1: ProxyArg<TokenId<Env::Api>>,
    >(
        self,
        first_token_id: Arg0,
        second_token_id: Arg1,
    ) -> TxTypedDeploy<Env, From, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_deploy()
            .argument(&first_token_id)
            .argument(&second_token_id)
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> OrderBookPairProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    pub fn create_buy_order_endpoint<
        Arg0: ProxyArg<OrderInputParams<Env::Api>>,
    >(
        self,
        params: Arg0,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("createBuyOrder")
            .argument(&params)
            .original_result()
    }

    pub fn create_sell_order_endpoint<
        Arg0: ProxyArg<OrderInputParams<Env::Api>>,
    >(
        self,
        params: Arg0,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("createSellOrder")
            .argument(&params)
            .original_result()
    }

    pub fn match_orders_endpoint<
        Arg0: ProxyArg<ManagedVec<Env::Api, u64>>,
    >(
        self,
        order_ids: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("matchOrders")
            .argument(&order_ids)
            .original_result()
    }

    pub fn cancel_orders_endpoint<
        Arg0: ProxyArg<MultiValueManagedVec<Env::Api, u64>>,
    >(
        self,
        order_ids: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("cancelOrders")
            .argument(&order_ids)
            .original_result()
    }

    pub fn cancel_all_orders_endpoint(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("cancelAllOrders")
            .original_result()
    }

    pub fn free_orders_endpoint<
        Arg0: ProxyArg<MultiValueManagedVec<Env::Api, u64>>,
    >(
        self,
        order_ids: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("freeOrders")
            .argument(&order_ids)
            .original_result()
    }

    pub fn global_op_start(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("startGlobalOperation")
            .original_result()
    }

    pub fn global_op_stop(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("stopGlobalOperation")
            .original_result()
    }

    pub fn get_address_order_ids<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueManagedVec<Env::Api, u64>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAddressOrderIds")
            .argument(&address)
            .original_result()
    }

    pub fn order_id_counter(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getOrderIdCounter")
            .original_result()
    }

    pub fn orders<
        Arg0: ProxyArg<u64>,
    >(
        self,
        id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Order<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getOrderById")
            .argument(&id)
            .original_result()
    }

    pub fn first_token_id(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, TokenId<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getFirstTokenId")
            .original_result()
    }

    pub fn second_token_id(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, TokenId<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getSecondTokenId")
            .original_result()
    }
}

#[type_abi]
#[derive(TopEncode, TopDecode, Clone)]
pub struct OrderInputParams<Api>
where
    Api: ManagedTypeApi,
{
    pub amount: NonZeroBigUint<Api>,
    pub match_provider: ManagedAddress<Api>,
    pub fee_config: FeeConfig<Api>,
    pub deal_config: DealConfig,
}

#[type_abi]
#[derive(ManagedVecItem, TopEncode, TopDecode, NestedEncode, NestedDecode, Clone)]
pub struct FeeConfig<Api>
where
    Api: ManagedTypeApi,
{
    pub fee_type: FeeConfigEnum,
    pub fixed_fee: BigUint<Api>,
    pub percent_fee: u64,
}

#[type_abi]
#[derive(ManagedVecItem, TopEncode, TopDecode, NestedEncode, NestedDecode, Clone)]
pub enum FeeConfigEnum {
    Fixed,
    Percent,
}

#[type_abi]
#[derive(ManagedVecItem, TopEncode, TopDecode, NestedEncode, NestedDecode, Clone, Default)]
pub struct DealConfig {
    pub match_provider_percent: u64,
}

#[type_abi]
#[derive(ManagedVecItem, TopEncode, TopDecode, NestedEncode, NestedDecode, Clone)]
pub struct Order<Api>
where
    Api: ManagedTypeApi,
{
    pub id: u64,
    pub creator: ManagedAddress<Api>,
    pub match_provider: ManagedAddress<Api>,
    pub input_amount: NonZeroBigUint<Api>,
    pub output_amount: NonZeroBigUint<Api>,
    pub fee_config: FeeConfig<Api>,
    pub deal_config: DealConfig,
    pub create_epoch: u64,
    pub order_type: OrderType,
}

#[type_abi]
#[derive(
    ManagedVecItem, TopEncode, TopDecode, NestedEncode, NestedDecode, PartialEq, Eq, Clone, Copy,
)]
pub enum OrderType {
    Buy,
    Sell,
}
